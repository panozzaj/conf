#!/usr/bin/env ruby
#
# ruby_versions
#
# A script to fetch Ruby release information from ruby-lang.org,
# compare it against the locally installed version, and display
# a sorted, color-coded list of releases.
#
# This script uses the 'nokogiri' gem to parse HTML.
# Please install it if you haven't: gem install nokogiri

require 'net/http'
require 'rubygems' # Required for Gem::Version
require 'tmpdir'
require 'date'
require 'optparse'

begin
  require 'nokogiri'
rescue LoadError
  puts "This script requires the 'nokogiri' gem to parse the HTML from ruby-lang.org."
  puts "Please run: gem install nokogiri"
  exit 1
end

# --- Options Parsing ---
options = {
  show_all_in_series: false,
  show_all_time: false,
}

OptionParser.new do |opts|
  opts.banner = "Usage: ruby_versions [options]"

  opts.on("-a", "--all-series", "Show all versions in each visible series (disables truncation).") do
    options[:show_all_in_series] = true
  end

  opts.on("-A", "--all-time", "Show all historical versions, ignoring the local version.") do
    options[:show_all_time] = true
  end

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end
end.parse!

# --- Configuration ---
RELEASES_URL = "https://www.ruby-lang.org/en/downloads/releases/"
DEBUG = ENV['DEBUG'] == 'true'

# --- Color Definitions ---
class String
  def green;  "\e[32m#{self}\e[0m" end
  def yellow; "\e[1;33m#{self}\e[0m" end
  def cyan;   "\e[36m#{self}\e[0m" end
  def grey;   "\e[90m#{self}\e[0m" end
  def red;    "\e[31m#{self}\e[0m" end
end

# --- Helper Methods ---
def is_older?(release_version, current_version, current_major_minor)
  release_major_minor = Gem::Version.new(release_version.segments[0..1].join('.'))
  (release_major_minor < current_major_minor) ||
  (release_major_minor == current_major_minor && release_version < current_version)
end

def print_release_line(release, is_latest_in_group:, current_version:, current_major_minor:)
    version_str = release[:version].to_s
    output_line = "  %-18s (Released: %s)" % [version_str, release[:date]]

    is_current = release[:version] == current_version
    is_old = is_older?(release[:version], current_version, current_major_minor)

    # Apply highlighting and coloring based on precedence
    if is_current
      puts "#{output_line}  <-- You are here".green
    elsif is_latest_in_group && is_old
      puts "#{output_line}  <-- Latest".grey
    elsif is_old
      puts output_line.grey
    elsif is_latest_in_group
      puts "#{output_line}  <-- Latest".cyan
    else
      puts output_line
    end
end

# --- Main Script Logic ---

# 1. Get the current Ruby version.
# The built-in RUBY_VERSION constant provides this directly.
puts "Checking your local Ruby version... #{RUBY_VERSION.cyan}"
current_version = Gem::Version.new(RUBY_VERSION)
current_major_minor = Gem::Version.new(current_version.segments[0..1].join('.'))

# 2. Fetch release data from the official Ruby website.
puts "Fetching release data from #{RELEASES_URL} ..."
uri = URI(RELEASES_URL)
response = Net::HTTP.get_response(uri)

unless response.is_a?(Net::HTTPSuccess)
  puts "\nFailed to fetch release data. HTTP Status: #{response.code}"
  exit 1
end

if DEBUG
  debug_file = File.join(Dir.tmpdir, "ruby_versions_debug.html")
  File.write(debug_file, response.body)
  puts "DEBUG: Wrote page content to #{debug_file}"
end

# 3. Parse the HTML and extract release information using Nokogiri.
releases = []
begin
  doc = Nokogiri::HTML(response.body)
  puts "DEBUG: Successfully parsed HTML with Nokogiri." if DEBUG
  # Find all table rows within the release list table.
  # Note: The table lacks a <tbody> element, so we select 'tr' directly.
  doc.css('table.release-list tr').each do |row|
    cells = row.css('td')
    next if cells.empty? # Skip header rows or malformed rows

    # Extract text content from the first two cells.
    version_text = cells[0]&.text&.strip
    date_text = cells[1]&.text&.strip

    # Clean up the version string and ensure both parts were found.
    if version_text&.start_with?('Ruby ') && date_text
      iso_date = begin
                   Date.parse(date_text).iso8601
                 rescue Date::Error
                   date_text # Fallback to original text if parsing fails
                 end
      # Remove "Ruby " prefix and create a Gem::Version object for accurate sorting.
      version_num = version_text.sub('Ruby ', '')
      releases << {
        version: Gem::Version.new(version_num),
        date: iso_date
      }
      puts "DEBUG: Added release #{version_num}" if DEBUG
    else
        puts "DEBUG: Skipped row, version_text: '#{version_text}', date_text: '#{date_text}'" if DEBUG
    end
  end
rescue => e
  puts "\nFailed to parse the HTML document. The page structure might have changed."
  puts "Error: #{e.message}"
  puts e.backtrace if DEBUG
  exit 1
end

# Filter out pre-releases if a final version for that patch exists.
base_versions = releases.group_by { |r| r[:version].segments[0..2].join('.') }
releases = base_versions.flat_map do |_, release_group|
  has_final_release = release_group.any? { |r| !r[:version].prerelease? }
  if has_final_release
    release_group.select { |r| !r[:version].prerelease? }
  else
    release_group
  end
end

if releases.empty?
  puts "\nCould not find any release information on the page."
  exit 1
end

# 4. Group releases by major.minor version and sort them.
# 'group_by' is perfect for this. The key is the major.minor string (e.g., "3.3").
# We sort the groups themselves by version number in descending order.
grouped_releases = releases.group_by { |r| r[:version].segments[0..1].join('.') }

sorted_groups = grouped_releases.keys.sort_by { |v| Gem::Version.new(v) }.reverse

# Filter to show only series that are current or newer.
visible_groups = sorted_groups.select { |group_key| Gem::Version.new(group_key) >= current_major_minor }
# If -A is passed, ignore the local version filtering and show everything.
visible_groups = sorted_groups if options[:show_all_time]

# 5. Iterate through the sorted groups and print the formatted output.
puts "" # Add a blank line for spacing
visible_groups.each do |group_key|
  puts "--- Ruby #{group_key} Releases ---".red

  # Sort the releases within each group from newest to oldest.
  sorted_versions_in_group = grouped_releases[group_key].sort_by { |r| r[:version] }.reverse

  truncate_output = sorted_versions_in_group.count > 10 && !options[:show_all_in_series] && !options[:show_all_time]

  if truncate_output
    latest_five = sorted_versions_in_group.first(5)
    earliest_five = sorted_versions_in_group.last(5)

    latest_five.each_with_index do |release, index|
      print_release_line(
        release,
        is_latest_in_group: index == 0,
        current_version: current_version,
        current_major_minor: current_major_minor
      )
    end

    last_of_the_latest = latest_five.last
    is_last_version_old = is_older?(last_of_the_latest[:version], current_version, current_major_minor)
    puts(is_last_version_old ? "  ...".grey : "  ...")

    earliest_five.each do |release|
      print_release_line(
        release,
        is_latest_in_group: false, # Never the latest in this context
        current_version: current_version,
        current_major_minor: current_major_minor
      )
    end
  else
    sorted_versions_in_group.each_with_index do |release, index|
      print_release_line(
        release,
        is_latest_in_group: index == 0,
        current_version: current_version,
        current_major_minor: current_major_minor
      )
    end
  end

  puts "" # Blank line between groups
end
