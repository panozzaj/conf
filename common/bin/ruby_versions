#!/usr/bin/env ruby
#
# ruby_versions
#
# A script to fetch Ruby release information from ruby-lang.org,
# compare it against the locally installed version, and display
# a sorted, color-coded list of releases.
#
# This script uses the 'nokogiri' gem to parse HTML.
# Please install it if you haven't: gem install nokogiri

require 'net/http'
require 'rubygems' # Required for Gem::Version
require 'tmpdir'
require 'date'
require 'optparse'
require 'set'

begin
  require 'nokogiri'
rescue LoadError
  puts "This script requires the 'nokogiri' gem to parse the HTML from ruby-lang.org."
  puts "Please run: gem install nokogiri"
  exit 1
end

# --- Options Parsing ---
options = {
  show_all_in_series: false,
  show_all_time: false,
}

OptionParser.new do |opts|
  opts.banner = "Usage: ruby_versions [options]"

  opts.on("-a", "--all-series", "Show all versions in each visible series (disables truncation).") do
    options[:show_all_in_series] = true
  end

  opts.on("-A", "--all-time", "Show all historical versions, ignoring the local version.") do
    options[:show_all_time] = true
  end

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end
end.parse!

# --- Configuration ---
RELEASES_URL = "https://www.ruby-lang.org/en/downloads/releases/"
DEBUG = ENV['DEBUG'] == 'true'

# --- Color Definitions ---
class String
  def green;  "\e[32m#{self}\e[0m" end
  def yellow; "\e[1;33m#{self}\e[0m" end
  def cyan;   "\e[36m#{self}\e[0m" end
  def grey;   "\e[90m#{self}\e[0m" end
  def red;    "\e[31m#{self}\e[0m" end
end

# --- Helper Methods ---
def is_older?(release_version, current_version, current_major_minor)
  release_major_minor = Gem::Version.new(release_version.segments[0..1].join('.'))
  (release_major_minor < current_major_minor) ||
  (release_major_minor == current_major_minor && release_version < current_version)
end

def print_release_line(release, is_latest_in_group:, current_version:, current_major_minor:)
    version_str = release[:version].to_s
    output_line = "  %-18s (Released: %s)" % [version_str, release[:date]]

    is_current = release[:version] == current_version
    is_old = is_older?(release[:version], current_version, current_major_minor)

    # Apply highlighting and coloring based on precedence
    if is_current
      puts "#{output_line}  <-- You are here".green
    elsif is_latest_in_group && is_old
      puts "#{output_line}  <-- Latest".grey
    elsif is_old
      puts output_line.grey
    elsif is_latest_in_group
      puts "#{output_line}  <-- Latest".cyan
    else
      puts output_line
    end
end

# --- Main Script Logic ---

# 1. Get the current Ruby version.
# The built-in RUBY_VERSION constant provides this directly.
puts "Checking your local Ruby version... #{RUBY_VERSION.cyan}"
current_version = Gem::Version.new(RUBY_VERSION)
current_major_minor = Gem::Version.new(current_version.segments[0..1].join('.'))

# 2. Fetch release data from the official Ruby website.
puts "Fetching release data from #{RELEASES_URL} ..."
uri = URI(RELEASES_URL)
response = Net::HTTP.get_response(uri)

unless response.is_a?(Net::HTTPSuccess)
  puts "\nFailed to fetch release data. HTTP Status: #{response.code}"
  exit 1
end

if DEBUG
  debug_file = File.join(Dir.tmpdir, "ruby_versions_debug.html")
  File.write(debug_file, response.body)
  puts "DEBUG: Wrote page content to #{debug_file}"
end

# 3. Parse the HTML and extract release information using Nokogiri.
releases = []
begin
  doc = Nokogiri::HTML(response.body)
  puts "DEBUG: Successfully parsed HTML with Nokogiri." if DEBUG
  # Find all table rows within the release list table.
  # Note: The table lacks a <tbody> element, so we select 'tr' directly.
  doc.css('table.release-list tr').each do |row|
    cells = row.css('td')
    next if cells.empty? # Skip header rows or malformed rows

    # Extract text content from the first two cells.
    version_text = cells[0]&.text&.strip
    date_text = cells[1]&.text&.strip

    # Clean up the version string and ensure both parts were found.
    if version_text&.start_with?('Ruby ') && date_text
      iso_date = begin
                   Date.parse(date_text).iso8601
                 rescue Date::Error
                   date_text # Fallback to original text if parsing fails
                 end
      # Remove "Ruby " prefix and create a Gem::Version object for accurate sorting.
      version_num = version_text.sub('Ruby ', '')
      releases << {
        version: Gem::Version.new(version_num),
        date: iso_date
      }
      puts "DEBUG: Added release #{version_num}" if DEBUG
    else
        puts "DEBUG: Skipped row, version_text: '#{version_text}', date_text: '#{date_text}'" if DEBUG
    end
  end
rescue => e
  puts "\nFailed to parse the HTML document. The page structure might have changed."
  puts "Error: #{e.message}"
  puts e.backtrace if DEBUG
  exit 1
end

# Filter out pre-releases if a final version for that patch exists.
base_versions = releases.group_by { |r| r[:version].segments[0..2].join('.') }
releases = base_versions.flat_map do |_, release_group|
  has_final_release = release_group.any? { |r| !r[:version].prerelease? }
  if has_final_release
    release_group.select { |r| !r[:version].prerelease? }
  else
    release_group
  end
end

if releases.empty?
  puts "\nCould not find any release information on the page."
  exit 1
end

# 4. Group releases by major.minor version and sort them.
# 'group_by' is perfect for this. The key is the major.minor string (e.g., "3.3").
# We sort the groups themselves by version number in descending order.
grouped_releases = releases.group_by { |r| r[:version].segments[0..1].join('.') }

sorted_groups = grouped_releases.keys.sort_by { |v| Gem::Version.new(v) }.reverse

# Filter to show only series that are current or newer.
visible_groups = sorted_groups.select { |group_key| Gem::Version.new(group_key) >= current_major_minor }
# If -A is passed, ignore the local version filtering and show everything.
visible_groups = sorted_groups if options[:show_all_time]

# 5. Iterate through the sorted groups and print the formatted output.
puts "" # Add a blank line for spacing
visible_groups.each do |group_key|
  puts "--- Ruby #{group_key} Releases ---".red

  sorted_versions_in_group = grouped_releases[group_key].sort_by { |r| r[:version] }.reverse

  # --- Build the list of items to display ---
  versions_to_display = []
  truncate_output = sorted_versions_in_group.count > 10 && !options[:show_all_in_series]

  if truncate_output
    indices_to_show = Set.new
    # Add top 5 indices
    (0..4).each { |i| indices_to_show.add(i) }
    # Add bottom 5 indices
    ((sorted_versions_in_group.length - 5)..(sorted_versions_in_group.length - 1)).each { |i| indices_to_show.add(i) }

    # Ensure current version is always visible
    current_version_index = sorted_versions_in_group.find_index { |r| r[:version] == current_version }
    indices_to_show.add(current_version_index) if current_version_index

    sorted_indices = indices_to_show.to_a.sort

    last_shown_index = -1
    sorted_indices.each do |index|
      # If there's a gap between the last shown version and this one, add an ellipsis.
      if last_shown_index != -1 && index > last_shown_index + 1
        versions_to_display.push(:ellipsis)
      end
      versions_to_display.push(sorted_versions_in_group[index])
      last_shown_index = index
    end
  else
    versions_to_display = sorted_versions_in_group
  end

  # --- Render the display list ---
  versions_to_display.each_with_index do |item, list_index|
    if item == :ellipsis
      previous_release = versions_to_display[list_index - 1]
      is_grey = is_older?(previous_release[:version], current_version, current_major_minor)
      puts(is_grey ? "  ...".grey : "  ...")
    else
      release = item
      is_latest = (release == sorted_versions_in_group.first)
      print_release_line(
        release,
        is_latest_in_group: is_latest,
        current_version: current_version,
        current_major_minor: current_major_minor
      )
    end
  end

  puts "" # Blank line between groups
end
